interpolate :: Tree -> String
interpolate solution = [i|

{-\# language ApplicativeDo \#-}

module Check (checkSemantics, checkSyntax) where


import Control.Monad                (when, unless)
import Control.OutputCapable.Blocks
import Control.OutputCapable.Blocks.Generic.Type (
    GenericOutput
    )
import Data.Ratio
import Text.Parsec                 (ParseError)

import Global
import Parse                       (parseSubmission)


checkSyntax :: OutputCapable m => FilePath -> Either ParseError Solution -> LangM m
checkSyntax _ (Left err) = refuse $ code $ show err
checkSyntax _ _          = pure ()


checkSemantics :: OutputCapable m => FilePath -> Either ParseError Solution -> Rated m
checkSemantics _ (Left err) = refuse (code $ show err) *>
                              pure 0.0
checkSemantics _ (Right (s,p)) = do
    assertion (s == getSum sol) $
      translate $ do
        german "Summe ist korrekt?"
        english "Sum ist correct?"
    assertion (p == getProd sol) $ do
      translate $ do
        german "Produkt ist korrekt?"
        english "Product is correct?"
    pure 1.0


sol = #{solution}

|]

