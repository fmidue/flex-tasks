module Global where


type Solution = (Int,Int)

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
{-# Language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}
module TaskAndForm where


import Control.OutputCapable.Blocks
import Control.OutputCapable.Blocks.Generic.Type (
    GenericOutput
    )
import Data.String.Interpolate (i)
import Data.Text               (Text)
import FlexTask.FormUtil       (getFormData)
import FlexTask.Generic.Form
import FlexTask.YesodConfig    (Handler, Rendered)
import GHC.Generics            (Generic)
import Test.QuickCheck.Gen

import qualified Data.Text as T

import Global




getTask :: OutputCapable m => FilePath -> Gen (LangM m, String, IO ([String],String))
getTask _ = do
    numbers <- vectorOf 3000 $ chooseInt (-100000,100000)
    pure (output numbers, interpolate numbers, getFormData form)



output :: OutputCapable m => [Int] -> LangM m
output input = do
  paragraph $ translate $ do
    german "Betrachten Sie die folgende Liste von Zahlen."
    english "Consider the following list of numbers."
  code $ show input
  paragraph $ translate $ do
    german "Wählen Sie zwei Elemente der Liste aus."
    english "Choose two elements of the list."
  paragraph $ translate $ do
    german "Die Antwort muss folgendes erfüllen:"
    english "Your answer has to satisfy the following:"
  itemizeM [
      translate $ do
       german "Keines hat zwei negative Nachbarn."
       english "None has two negative Neighbours."
    , translate $ do
       german "Keines hat zwei durch 3 teilbare Nachbarn."
       english "None has two Neighbours divisible by 3."
    ]
  pure ()


fields :: [[FieldInfo]]
fields = [[Single "Number one"], [Single "Number two"]]


form :: Rendered
form = formify (Nothing :: Maybe Solution) fields

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
module ParseAndCheck where


import Data.String.Interpolate (i)
import Data.Text               (Text)
import FlexTask.Generic.Parse  (parseInput)
import GHC.Generics            (Generic)
import Text.Parsec             (ParseError, parse)

import qualified Data.Text as T

import Global




parseSubmission :: String -> Either ParseError Solution
parseSubmission = parse parseInput ""

=============================================


interpolate solution = [i|


import Control.Monad                (when, unless)
import Control.OutputCapable.Blocks
import Control.OutputCapable.Blocks.Generic.Type (
    GenericOutput,
    )
import Data.Ratio


checkSyntax :: OutputCapable m => FilePath -> Either ParseError Solution -> LangM m
checkSyntax _ (Left err) = refuse $ code $ show err
checkSyntax _ (Right (a,b))= do
    assertion (all (`elem` sol) [a,b]) $
      translate $ do
        german "Das Tupel kommt im Kreuzprodukt vor?"
        english "Tuple is inside the cross product?"
    pure ()
  where
    sol = #{solution}


checkSemantics :: OutputCapable m => FilePath -> Either ParseError Solution -> Rated m
checkSemantics _ (Left err) = refuse (code $ show err) *> pure 0.0
checkSemantics _ (Right (a,b)) = do
    assertion (all (`elem` #{noNegNeighbours}) [a,b]) $
      translate $ do
        german "Mindestens ein Nachbar ist positiv?"
        english "At least one Neighbour is positive?"
    assertion (all (`elem` #{noDiv3Neighbours}) [a,b]) $
      translate $ do
        german "Nachbarn sind nicht durch drei teilbar?"
        english "Neighbours are not divisible by three?"
    pure 1.0
|]
  where
    neighbourTups = zip3 solution (drop 1 solution) (drop 2 solution)
    fromNeighbourTups f = map (\(a,b,c) -> b) $ filter f $ neighbourTups
    noNegNeighbours = fromNeighbourTups (\(a,b,c) -> a >= 0 || c >= 0)
    noDiv3Neighbours = fromNeighbourTups (\(a,b,c) -> a `mod` 3 /= 0 || c `mod` 3 /= 0)

