module Global where


type Solution = (Int,Int)

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
{-# Language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}
module TaskAndForm where


import Control.Monad.Output
import Control.Monad.Output.Generic.Type (GenericOutput)
import Data.String.Interpolate           (i)
import Data.Text                         (Text)
import FlexTask.FormUtil                 (flatten, getHtml)
import FlexTask.Generic.Form
import FlexTask.YesodConfig              (Handler, Widget)
import GHC.Generics                      (Generic)
import Test.QuickCheck.Gen
import Text.Blaze.Internal               (MarkupM)
import Yesod                             (Html, MForm)

import qualified Data.Text as T

import Global




getTask :: OutputMonad m => FilePath -> Gen (LangM m, String, IO Html, [[Text]])
getTask _ = do
    numbers <- vectorOf 3000 $ chooseInt (-100000,100000)
    pure (output numbers, interpolate numbers, getHtml flattened widget, flattened)
  where
    flattened = flatten fieldNames



output :: OutputMonad m => [Int] -> LangM m
output input = do
  paragraph $ translate $ do
    german "Betrachten Sie die folgende Liste von Integer-Zahlen."
    english "Consider the following list of Integer numbers."
  code $ show input
  paragraph $ translate $ do
    german "Stellen Sie sich vor wir bilden das Kreuzprodukt dieser Liste mit sich selbst."
    english "Now imagine we are calculating the cross product of this list with itself."
  paragraph $ translate $ do
    german "Geben Sie ein Zahlen-Tupel an, dass in diesem Kreuzprodukt "
    german "enthalten ist und folgende Bedingungen erfüllt:"
    english "Enter a tuple of numbers which is contained in this cross product "
    english "and satisfies the following conditions:"
  itemizeM [
      translate $ do 
        german "Eine Zahl ist positiv, eine negativ."
        english "One number is positive, one is negative."
    , translate $ do 
        german "Das Product der Zahlen ist eine gerade Zahl."
        english "The product of the numbers is even."
    , translate $ do 
        german "Keine der Zahlen steht in der ursprünglichen Liste zwischen zwei negativen Zahlen."
        english "None of the numbers is between two negative numbers in the original list."
    , translate $ do 
        german "Keine der Zahlen steht in der ursprünglichen Liste "
        german "zwischen zwei glatt durch 3 teilbahren Zahlen."
        english "None of the numbers is between "
        english "two numbers wholly divisible by 3 in the original list."
    ]
  pure ()


fieldNames :: [[FieldInfo]]
fieldNames = [[Single "Number one"], [Single "Number two"]]


widget :: Html -> MForm Handler Widget
widget = formify (Nothing :: Maybe Solution) fieldNames

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
module ParseAndCheck where


import Data.String.Interpolate (i)
import Data.Text               (Text)
import FlexTask.Generic.Parse  (parseInput)
import GHC.Generics            (Generic)
import Text.Parsec             (ParseError, parse)

import qualified Data.Text as T

import Global




parseSubmission :: String -> Either ParseError Solution
parseSubmission = parse parseInput ""

=============================================


interpolate solution = [i|


import Control.Monad                     (when, unless)
import Control.Monad.Output
import Control.Monad.Output.Generic.Type (GenericOutput)
import Data.Ratio


checkSyntax :: OutputMonad m => FilePath -> Either ParseError Solution -> LangM m
checkSyntax _ (Left err) = refuse $ code $ show err
checkSyntax _ (Right (a,b))
  | not (all (`elem` sol) [a,b]) =
      refuse $ indent $ translate $ do
        german "Das Tupel kommt nicht im Kreuzprodukt vor"
        english "The tuple is not inside the cross product"
  
  | otherwise = pure ()
  where
    sol = #{solution}


checkSemantics :: OutputMonad m => FilePath -> Either ParseError Solution -> Rated m
checkSemantics _ (Left err) = refuse (code $ show err) *> pure 0.0
checkSemantics _ (Right (a,b)) = do
    unless (signum a + signum b == 0) $
      refuse $ indent $ translate $ do
          german "Die Zahlen haben kein unterschiedliches Vorzeichen."
          english "The numbers do not have different signs"
    unless (even (a * b)) $
      refuse $ indent $ translate $ do
          german "Das Produkt der Zahlen ist nicht gerade."
          english "The product of the numbers is not even."
    unless (all (`elem` #{noNegNeighbours}) [a,b]) $
      refuse $ indent $ translate $ do
          german "Mindesten eine Zahl ist zwischen negativen Zahlen."
          english "At least one number is between two negative numbers."
    pure 1.0
    unless (all (`elem` #{noDiv3Neighbours}) [a,b]) $
      refuse $ indent $ translate $ do
          german "Mindesten eine Zahl ist zwischen zwei durch 3 teilbaren Zahlen."
          english "At least one number is between two numbers divisible by three."
    pure 1.0

|]
  where
    neighbourTups = zip3 solution (drop 1 solution) (drop 2 solution)
    fromNeighbourTups f = map (\(a,b,c) -> b) $ filter f $ neighbourTups
    noNegNeighbours = fromNeighbourTups (\(a,b,c) -> a >= 0 || c >= 0)
    noDiv3Neighbours = fromNeighbourTups (\(a,b,c) -> a `mod` 3 /= 0 || c `mod` 3 /= 0)

