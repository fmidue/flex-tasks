module Global where

data Tree = Leaf Int | Branch (Maybe Tree) (Maybe Tree) Int deriving (Show,Eq)


addToTree :: [Int] -> Tree
addToTree [] = error "no"
addToTree (x:xs) = foldl sortIn (Leaf x) xs


sortIn :: Tree -> Int -> Tree
sortIn (Leaf x) y
  | x > y = Branch Nothing (Just $ Leaf y) x
  | otherwise = Branch (Just $ Leaf y) Nothing x
sortIn (Branch t1 t2 x) y
  | x > y = case t2 of
              Nothing   -> Branch t1 (Just $ Leaf y) x
              Just tree -> Branch t1 (Just $ sortIn tree y) x
  | otherwise = case t1 of
                  Nothing   -> Branch (Just $ Leaf y) t2 x
                  Just tree -> Branch (Just $ sortIn tree y) t2 x


getSum :: Tree -> Int
getSum (Leaf x) = x
getSum (Branch t1 t2 x) = x + maybe 0 getSum t1 + maybe 0 getSum t2


getProd :: Tree -> Int
getProd (Leaf x) = x
getProd (Branch t1 t2 x) = x * maybe 1 getProd t1 * maybe 1 getProd t2


type Solution = (Int,Int)

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
{-# Language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}
module TaskAndForm where


import Control.Monad.Output
import Control.Monad.Output.Generic.Type (GenericOutput)
import Data.String.Interpolate           (i)
import Data.Text                         (Text)
import FlexTask.FormUtil                 (getFormData)
import FlexTask.Generic.Form
import FlexTask.YesodConfig              (Handler, Rendered)
import GHC.Generics                      (Generic)
import Test.QuickCheck.Gen
import Text.Blaze.Internal               (MarkupM)
import Yesod                             (Html, MForm)

import qualified Data.Text as T

import Global




getTask :: OutputMonad m => FilePath -> Gen (LangM m, String, IO ([Text],Html))
getTask _ = do
    tree <- addToTree <$> vectorOf 3000 (chooseInt (-100000,100000))
    pure (output tree, interpolate tree, getFormData form)



output :: OutputMonad m => Tree -> LangM m
output input = do
  code $ show input
  pure ()


fields :: [[FieldInfo]]
fields = [[Single "Tree Sum"],[Single "Tree Product"]]


form :: Rendered
form = formify (Nothing :: Maybe Solution) fields

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
module ParseAndCheck where


import Data.String.Interpolate (i)
import Data.Text               (Text)
import FlexTask.Generic.Parse  (parseInput)
import GHC.Generics            (Generic)
import Text.Parsec             (ParseError, parse)

import qualified Data.Text as T

import Global




parseSubmission :: String -> Either ParseError Solution
parseSubmission = parse parseInput ""

=============================================


interpolate solution = [i|


import Control.Monad                     (when, unless)
import Control.Monad.Output
import Control.Monad.Output.Generic.Type (GenericOutput)
import Data.Ratio


checkSyntax :: OutputMonad m => FilePath -> Either ParseError Solution -> LangM m
checkSyntax _ (Left err) = refuse $ code $ show err
checkSyntax _ _          = pure ()


checkSemantics :: OutputMonad m => FilePath -> Either ParseError Solution -> Rated m
checkSemantics _ (Left err) = refuse (code $ show err) *> pure 0.0
checkSemantics _ (Right (s,p)) = do
    unless (s == #{getSum solution}) $ do
      refuse $ text $ "Nein"
    unless (p == #{getProd solution}) $ do
      refuse $ text $ "Nein"
    pure 1.0

|]


