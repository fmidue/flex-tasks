module Global where

data Tree = Leaf Int | Branch (Maybe Tree) (Maybe Tree) Int deriving (Show,Eq)


addToTree :: [Int] -> Tree
addToTree [] = error "no"
addToTree (x:xs) = foldl sortIn (Leaf x) xs


sortIn :: Tree -> Int -> Tree
sortIn (Leaf x) y
  | x > y = Branch Nothing (Just $ Leaf y) x
  | otherwise = Branch (Just $ Leaf y) Nothing x
sortIn (Branch t1 t2 x) y
  | x > y = case t2 of
              Nothing   -> Branch t1 (Just $ Leaf y) x
              Just tree -> Branch t1 (Just $ sortIn tree y) x
  | otherwise = case t1 of
                  Nothing   -> Branch (Just $ Leaf y) t2 x
                  Just tree -> Branch (Just $ sortIn tree y) t2 x


getSum :: Tree -> Int
getSum (Leaf x) = x
getSum (Branch t1 t2 x) = x + maybe 0 getSum t1 + maybe 0 getSum t2


getProd :: Tree -> Int
getProd (Leaf x) = x
getProd (Branch t1 t2 x) = x * maybe 1 getProd t1 * maybe 1 getProd t2


type Solution = (Int,Int)

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
{-# Language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}
module TaskAndForm where


import Control.OutputCapable.Blocks
import Control.OutputCapable.Blocks.Generic.Type (
    GenericOutput
    )
import Data.String.Interpolate (i)
import Data.Text               (Text)
import FlexTask.FormUtil       (getFormData)
import FlexTask.Generic.Form
import FlexTask.YesodConfig    (Handler, Rendered)
import GHC.Generics            (Generic)
import Test.QuickCheck.Gen

import qualified Data.Text as T

import Global




getTask :: OutputCapable m => FilePath -> Gen (LangM m, String, IO ([String],String))
getTask _ = do
    tree <- addToTree <$> vectorOf 3000 (chooseInt (-100000,100000))
    pure (output tree, interpolate tree, getFormData form)



output :: OutputCapable m => Tree -> LangM m
output input = do
  code $ show input
  pure ()


fields :: [[FieldInfo]]
fields = [[Single "Tree Sum"],[Single "Tree Product"]]


form :: Rendered
form = formify (Nothing :: Maybe Solution) fields

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
module ParseAndCheck where


import Data.String.Interpolate (i)
import Data.Text               (Text)
import FlexTask.Generic.Parse  (parseInput)
import GHC.Generics            (Generic)
import Text.Parsec             (ParseError, parse)

import qualified Data.Text as T

import Global




parseSubmission :: String -> Either ParseError Solution
parseSubmission = parse parseInput ""

=============================================


interpolate solution = [i|


import Control.Monad                (when, unless)
import Control.OutputCapable.Blocks
import Control.OutputCapable.Blocks.Generic.Type (
    GenericOutput
    )
import Data.Ratio


checkSyntax :: OutputCapable m => FilePath -> Either ParseError Solution -> LangM m
checkSyntax _ (Left err) = refuse $ code $ show err
checkSyntax _ _          = pure ()


checkSemantics :: OutputCapable m => FilePath -> Either ParseError Solution -> Rated m
checkSemantics _ (Left err) = refuse (code $ show err) *>
                              pure 0.0
checkSemantics _ (Right (s,p)) = do
    assertion (s == #{getSum solution}) $
      translate $ do
        german "Summe ist korrekt?"
        english "Sum ist correct?"
    assertion (p == #{getProd solution}) $ do
      translate $ do
        german "Produkt ist korrekt?"
        english "Product is correct?"
    pure 1.0
|]


