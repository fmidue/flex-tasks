{-# OPTIONS_GHC -Wno-unused-imports #-}

module Global where


import TermTasks.Records (
  Certain(..),
  SigInstance(..),
  Base(..),
  )

import TermTasks.DataType (
  Error(..),
  Signature(..),
  Symbol(..),
  Term(..),
  Type(..),
  toSignature,
  )


type Submission = [Int]
type TaskData = SigInstance


-- Making the config to use for this task. Signatures will be randomly picked out of a pool of options.
makeConfig :: Signature -> Certain
makeConfig sig = Certain {
  signatures = sig,
  root = Nothing,
  baseConf = Base {
    termSizeRange = ( 6, 10 ),
    wrongTerms = [(1, Swap), (1, TypeChange), (1, OneMore), (1, OneLess)],
    properTerms = 5,
    extraFeedback = True,
    printSolution = True
  }
}


-- Possible signatures to roll for the task
sigList :: [Signature]
sigList = [

{- all too long:

  -- ekg-push-1.json
  toSignature [
      ("defaultPushOptions", [], "PushOptions"),
      ("prefix", ["PushOptions"], "Text"),
      ("suffix", ["PushOptions"], "Text"),
      ("debug", ["PushOptions"], "Bool"),
      ("flushInterval", ["PushOptions"], "Int"),
      ("makeOptions", ["Int", "Bool", "Text", "Text"], "PushOptions")
      ],

  -- Euterpea-1.json
  toSignature [
      ("trackEnd", [], "Message"),
      ("key", ["Message"], "Key"),
      ("controllerNumber", ["Message"], "Int"),
      ("channel", ["Message"], "Channel"),
      ("controlChange", ["Channel", "Int", "Int"], "Message"),
      ("timeSignature", ["Int", "Int", "Int", "Int"], "Message")
      ],

  -- hS3-1.json
  toSignature [
      ("defaultAmazonS3Port", [], "Int"),
      ("defaultAmazonS3Host", [], "String"),
      ("makeAWSConnection", ["String", "Int", "String", "String"], "AWSConnection"),
      ("awsPort", ["AWSConnection"], "Int"),
      ("amazonS3Connection", ["String", "String"], "AWSConnection"),
      ("awsAccessKey", ["AWSConnection"], "String")
      ],

  -- unliftio-path-1.json
  toSignature [
      ("emptyPermissions", [], "Permissions"),
      ("exeExtension", [], "String"),
      ("readable", ["Permissions"], "Bool"),
      ("setOwnerReadable", ["Bool", "Permissions"], "Permissions"),
      ("setOwnerSearchable", ["Bool", "Permissions"], "Permissions"),
      ("executable", ["Permissions"], "Bool")
      ],
-}

  -- Cabal-syntax-2.json
  toSignature [
      ("zeroPos", [], "Position"),
      ("retPos", ["Position"], "Position"),
      ("showPos", ["Position"], "String"),
      ("positionRow", ["Position"], "Int"),
      ("makePosition", ["Int", "Int"], "Position"),
      ("incPos", ["Int", "Position"], "Position")
      ],

  -- french-cards-1.json
  toSignature [
      ("rTwo", [], "Rank"),
      ("diamonds", [], "Suit"),
      ("newCard", ["Rank", "Suit"], "Card"),
      ("cardRank", ["Card"], "Rank"),
      ("cardWord", ["Card"], "Word8"),
      ("cardSuit", ["Card"], "Suit")
      ],

  -- ghc-26.json
  toSignature [
      ("boxedTuple", [], "TupleSort"),
      ("finalPhase", [], "CompilerPhase"),
      ("activeAfter", ["CompilerPhase"], "Activation"),
      ("isAlwaysActive", ["Activation"], "Bool"),
      ("isActive", ["CompilerPhase", "Activation"], "Bool"),
      ("beginPhase", ["Activation"], "CompilerPhase")
      ],

  -- haskellscrabble-2.json
  toSignature [
      ("emptyBoard", [], "Board"),
      ("posMax", [], "Int"),
      ("prettyPrint", ["Board"], "String"),
      ("makePos", ["Int", "Int", "String"], "Pos"),
      ("yPos", ["Pos"], "Int"),
      ("gridValue", ["Pos"], "String")
      ],

  -- LPFP-core-3.json
  toSignature [
      ("defaultPFS", [], "ParticleFieldState"),
      ("position", ["ParticleFieldState"], "Position"),
      ("mass", ["ParticleFieldState"], "R"),
      ("scalePos", ["R", "Position"], "Position"),
      ("pfsUpdate", ["R", "ParticleFieldState"], "ParticleFieldState"),
      ("charge", ["ParticleFieldState"], "R")
      ],

  -- packedstring-2.json
  toSignature [
      ("nilPS", [], "PackedString"),
      ("lengthPS", ["PackedString"], "Int"),
      ("appendPS", ["PackedString", "PackedString"], "PackedString"),
      ("dropPS", ["Int", "PackedString"], "PackedString"),
      ("nullPS", ["PackedString"], "Bool"),
      ("unpackPS", ["PackedString"], "String")
      ],

  -- prettyprint-avh4-2.json
  toSignature [
      ("space", [], "Line"),
      ("blankLine", [], "Block"),
      ("line", ["Line"], "Block"),
      ("indent", ["Block"], "Block"),
      ("render", ["Block"], "Builder"),
      ("addSuffix", ["Line", "Block"], "Block")
      ],

  -- protobuf-1.json
  toSignature [
      ("empty", [], "Builder"),
      ("append", ["Builder", "Builder"], "Builder"),
      ("size", ["Builder"], "Int"),
      ("toLazyByteString", ["Builder"], "ByteString"),
      ("fromByteString", ["ByteString"], "Builder"),
      ("makeBuilder", ["Int", "Builder"], "Builder")
      ],

  -- template-toolkit-1.json
  toSignature [
      ("undef", [], "Val"),
      ("not", [], "UnOp"),
      ("eVal", ["Val"], "Expr"),
      ("eUnOp", ["UnOp", "Expr"], "Expr"),
      ("eTerOp", ["Expr", "Expr", "Expr"], "Expr"),
      ("vArrayRange", ["Expr", "Expr"], "Val")
      ],

  -- time-1.json
  toSignature [
      ("midnight", [], "TimeOfDay"),
      ("midday", [], "TimeOfDay"),
      ("todHour", ["TimeOfDay"], "Int"),
      ("todSec", ["TimeOfDay"], "Pico"),
      ("makeTime", ["Int", "Int", "Pico"], "TimeOfDay"),
      ("sinceMidnight", ["TimeOfDay"], "DiffTime")
      ],

  -- web-rep-2.json
  toSignature [
      ("defaultSocketConfig", [], "SocketConfig"),
      ("defaultSocketPage", [], "Page"),
      ("path", ["SocketConfig"], "Text"),
      ("host", ["SocketConfig"], "Text"),
      ("port", ["SocketConfig"], "Int"),
      ("makeConfig", ["Text", "Int", "Text"], "SocketConfig")
      ]
  ]

=============================================

{-# language OverloadedStrings #-}
{-# language QuasiQuotes #-}
{-# language RecordWildCards #-}

module TaskData where

import Data.Functor                     ((<&>))
import Data.String                      (fromString)
import Data.String.Interpolate          (i)
import Data.Text                        (Text)
import FlexTask.FormUtil                (getFormData)
import FlexTask.Generic.Form
import FlexTask.Types                   (HtmlDict)
import FlexTask.YesodConfig             (Rendered, Widget)
import TermTasks.Direct                 (genInst)
import TermTasks.Records (
  Certain,
  SigInstance(..),
  )
import Test.QuickCheck.Gen              (Gen, elements)
import Yesod                            (RenderMessage(..), fieldSettingsLabel)

import Global



data HeaderLabel = HeaderLabel


instance MonadFail Gen where
  fail = error


instance RenderMessage app HeaderLabel where
  renderMessage _ ("en":_) HeaderLabel  = "Correct Terms"
  renderMessage _ _        HeaderLabel  = "Korrekte Terme"


getTask :: Gen (TaskData, String, IO ([Text],HtmlDict))
getTask = do
    config <- genConfig
    inst@SigInstance{..} <- genInst config
    pure (inst, checkers, getFormData $ form $ length terms)


form :: Int -> Rendered Widget
form amount = formify
  (Nothing :: Maybe MultipleChoiceSelection)
  [[buttons Vertical (fieldSettingsLabel HeaderLabel) $ map (fromString . (++ ".") . show) [1..amount]]]


genConfig :: Gen Certain
genConfig = elements sigList <&> makeConfig


checkers :: String
checkers = [i|

module Check where


import Control.Applicative              (Alternative)
import Control.OutputCapable.Blocks
import TermTasks.Direct                 (completeGrade, partialGrade)

import Global



checkSyntax
  :: OutputCapable m
  => FilePath
  -> TaskData
  -> Submission
  -> LangM m
checkSyntax _ = partialGrade


checkSemantics
  :: (Alternative m, OutputCapable m)
  => FilePath
  -> TaskData
  -> Submission
  -> Rated m
checkSemantics _ = completeGrade

|]

=============================================

module Description (description) where

import Control.OutputCapable.Blocks
import qualified TermTasks.Direct       as TD

import Global



description :: OutputCapable m => FilePath -> TaskData -> LangM m
description _ = TD.description False

=============================================

module Parse (parseSubmission) where


import Control.OutputCapable.Blocks (
  LangM',
  OutputCapable,
  ReportT,
  )
import FlexTask.Generic.Parse  (formParser, parseWithOrReport, reportWithFieldNumber)

import Global



parseSubmission ::
  (Monad m, OutputCapable (ReportT o m))
  => String
  -> LangM' (ReportT o m) Submission
parseSubmission = parseWithOrReport formParser reportWithFieldNumber
