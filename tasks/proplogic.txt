module Global where

import Data.Text


data Table = Table [[Maybe Text]] deriving (Show,Eq)
data Namen = Anna | Ben | Claudia | David deriving (Eq,Enum,Bounded,Show)

type Solution = (Table,Text,[Namen])

=============================================
{-# language DeriveGeneric #-}
{-# Language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}
module TaskAndForm where


import Data.List.Split (chunksOf)
import Data.Text (Text)
import Data.String.Interpolate(i)
import Test.QuickCheck.Gen
import Yesod

import FormUtil
import Global

import qualified Data.Text as T


instance MonadFail Gen where
  fail = error

instance Formify [Namen] where
  formifyImplementation = formifyInstanceMultiChoice



getParticipants :: Gen [Bool]
getParticipants = suchThat (vectorOf 4 chooseAny) $ not . all (==False)

getTask = do
    values@[a,b,c,d] <- getParticipants
    let f = formula a b c d
        description = output a b c d
        zipped = zip values ([minBound .. maxBound] :: [Namen])
        coming = [ n | (b,n) <- zipped, b==True]

    pure (description, show (Table [],f,coming), getHtml flattened widget, flattened)
  where
    flattened = flatten fieldNames



formula :: Bool -> Bool -> Bool -> Bool -> Text
formula a b c d = [i|(#{part4}) ∧ (#{part1}) ∧ (#{part2}) ∧ (#{part3}) ∧ (#{part5})|]
  where
    neg f x = if f then "¬ " ++ x else x
    part1 = [i|#{neg a "A"} ⇒ #{neg b "B"}|] :: Text
    part2 = [i|#{neg b "B"} ⇒ #{neg c "C"}|] :: Text
    part3 = [i|#{neg c "C"} ⇒ #{neg d "D"}|] :: Text
    part4 = [i|(#{neg b "B"} ∧ #{neg d "D"}) ⇒ #{neg (not c) "C"}|] :: Text
    part5 = [i|#{neg d "D"} ⇒ (#{neg a "A"} ∨ #{neg b "B"})|] :: Text

output a b c d = (germanText a b c d,"")


germanText :: Bool -> Bool -> Bool -> Bool -> String
germanText a b c d = [i|
Eva möchte gerne auf ein Konzert ihrer Lieblingsband gehen.
Sie fragt ihre Freunde Astrid (A), Ben (B), Claudia (C) und David (D), ob sie mitkommen wollen.
Leider sind die Antworten etwas seltsam.

- #{hint4}
- #{hint1}
- #{hint2}
- #{hint3}
- #{hint5}

Übersetzen Sie die Aussagen in eine aussagenlogische Formel. Geben Sie diese Formel in das gleichnamige Textfeld ein.

Wer geht mit Eva zum Konzert? Begründen Sie Ihr Ergebnis systematisch. Kreuzen Sie dafür alle Konzertgänger in der Namensliste an.

|]
  where
    nicht :: Bool -> String
    nicht f = if f then "nicht" else ""
    -- to avoid inline type annotations due to String vs Text
    auch :: String
    auch = " auch"

    hint1 = [i|Ben kommt #{nicht b} mit, wenn Astrid #{nicht a} mitkommt.|] :: String
    hint2 = [i|Wenn Ben #{nicht b} kommt, kommt #{if b == c then auch else ""} Claudia #{nicht c}.|] :: String
    hint3 = [i|Wenn Claudia #{nicht c} kommt, kommt #{if c == d then auch else ""} David #{nicht d}.|] :: String
    hint4 =
      (if b == d
         then [i|Falls Ben und David #{nicht b} kommen,|]
         else
           if b
             then "Falls Ben nicht, aber David kommt,"
             else "Falls Ben, aber nicht David kommt,")
      ++ [i| kommt Claudia #{nicht (not c)}.|] :: String

    hint5 =
      [i|Wenn David #{nicht d} kommt, |] ++
      if a == b
        then [i|kommen #{if d == a then auch else ""} Astrid oder Ben #{nicht a}.|]
        else
          if a
            then [i|kommt #{if d then auch else ""} Astrid nicht oder Ben kommt.|]
            else [i|kommt #{if d then "" else auch} Astrid oder Ben kommt nicht.|]


instance Formify Table where
  formifyImplementation ((List _ fs : xs) : xss) = (rest, form)
    where
      rest = if null xs then xss else xs : xss
      form :: Html -> MForm Handler (FormResult Table, Widget)
      form extra = do
        let addCssClass fs = fs {fsAttrs = addClass "tableInput" (fsAttrs fs)}
        results <- sequence $ map (\f -> mopt textField (addCssClass (addName f)) Nothing) fs
        let headers = map snd $ take 3 results
            rows = chunksOf 7 $ map snd $ drop 3 results
            widget =
             [whamlet|
                 <style>
                   .tableInput {
                    width: 100%;
                   }
                   table, th, td {
                     border: 1px solid black;
                     border-collapse: collapse;

                   }
                   table {
                     width: 100%;
                   }
                 #{extra}
                 <table>
                   <tr>
                     <th>A
                     <th>B
                     <th>C
                     <th>D
                     $forall header <- headers
                       <th>^{fvInput header}
                   $forall row <- rows
                     <tr>
                       $forall input <- row
                         <td>^{fvInput input}
             |]

        return (Table <$> (pure <$> traverse fst results), widget)
  formifyImplementation _ = error "field names structure incorrect for table"


fieldNames :: [[FieldInfo]]
fieldNames = [[List Vertical (map (T.pack . show) [1..115])], [Single "Formel"], [ChoicesButtons Vertical "Wer kommt?" ["Anna","Ben","Claudia","David"]]]


widget :: Html -> MForm Handler (FormResult Solution, Widget)
widget = formify fieldNames

=============================================

{-# language DeriveGeneric #-}
{-# language OverloadedStrings #-}
module ParseAndCheck where


import Data.String.Interpolate(i)
import Data.Text (Text)
import Data.List.Split (chunksOf)
import Text.Parsec (ParseError, parse, many1, try)
import Text.Parsec.String (Parser)
import GHC.Generics

import Global
import ParseUtil

import qualified Data.Text as T


instance Parse [Namen] where
  parseInput = parseInstanceMultiChoice


instance Parse Table where
  parseInput = do
    values <- parseInput
    let headers = take 3 values
        rest = drop 3 values
    pure $ Table $ headers : chunksOf 7 rest


parseSubmission :: String -> Either ParseError Solution
parseSubmission = parse parseInput ""

=============================================

\solution -> [i|

checkSyntax :: Either ParseError Solution -> Maybe String
checkSyntax (Left err) = Just $ show err
checkSyntax (Right (_,t,n))
    | null n = Just "Es wurden keine Namen angekreuzt."
    | T.any isNumber t = Just "Die Formel enthält Zahlen."
    | T.any notInAnswer "ABCD" = Just "Die Formel enthält nicht alle vorkommenden Literale."
    | otherwise = Nothing
  where
    isNumber c = c `elem` ['1'..'9']
    notInAnswer c = not (c `T.elem` t)

checkSemantics :: Either ParseError Solution -> Maybe String
checkSemantics (Left err) = Just $ show err
checkSemantics (Right (_,t,n))
    | n /= nSol = Just "Die Liste der Teilnehmer ist falsch."
    | t /= tSol = Just "Die aussagenlogische Formel ist falsch."
    | otherwise = Nothing
  where
    (_,tSol,nSol) = sol

sol = #{solution}
|]


