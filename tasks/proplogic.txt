
{-# language DeriveGeneric #-}
{-# Language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}
module TaskAndForm where


import Data.Text (Text)
import Data.String.Interpolate(i)
import Test.QuickCheck.Gen
import Yesod

import FormUtil

instance MonadFail Gen where
  fail = error



data Namen = Anna | Ben | Claudia | David deriving (Eq,Enum,Bounded,Show)

instance Formify [Namen] where
  formifyImplementation = formifyInstanceMultiChoice


data Table = Table [[Maybe Text]] deriving (Show,Eq)

type Solution = (Table,Text,[Namen])

getBools :: Gen [Bool]
getBools = suchThat (vectorOf 4 chooseAny) $ not . all (==False)

getTask = do
    bools@[a,b,c,d] <- getBools
    let f = formula a b c d
        description = output a b c d
        zipped = zip bools ([minBound .. maxBound] :: [Namen])
        coming = [ n | (b,n) <- zipped, b==True]
        
    pure (description, show (Table [],f,coming), getHtml flattened widget, flattened)
  where
    flattened = flatten fieldNames



formula :: Bool -> Bool -> Bool -> Bool -> Text
formula a b c d = [i|(#{part4}) ∧ (#{part1}) ∧ (#{part2}) ∧ (#{part3}) ∧ (#{part5})|]
  where
    neg f x = if f then "¬ " ++ x else x
    part1 = [i|#{neg a "A"} ⇒ #{neg b "B"}|] :: Text
    part2 = [i|#{neg b "B"} ⇒ #{neg c "C"}|] :: Text
    part3 = [i|#{neg c "C"} ⇒ #{neg d "D"}|] :: Text
    part4 = [i|(#{neg b "B"} ∧ #{neg d "D"}) ⇒ #{neg (not c) "C"}|] :: Text
    part5 = [i|#{neg d "D"} ⇒ (#{neg a "A"} ∨ #{neg b "B"})|] :: Text

output a b c d = (beschreibung a b c d, show $ formula a b c d)


beschreibung :: Bool -> Bool -> Bool -> Bool -> String
beschreibung a b c d = [i|
Eva möchte gerne auf ein Konzert ihrer Lieblingsband gehen. 
Sie fragt ihre Freunde Astrid (A), Ben (B), Claudia (C) und David (D), ob sie mitkommen wollen.
Leider sind die Antworten etwas seltsam.

- #{hint4}
- #{hint1}
- #{hint2}
- #{hint3}
- #{hint5}

Übersetzen Sie die Aussagen in eine aussagenlogische Formel. Geben Sie diese Formel in das gleichnamige Textfeld ein.

Wer geht mit Eva zum Konzert? Begründen Sie Ihr Ergebnis systematisch. Kreuzen Sie dafür alle Konzertgänger in der Namensliste an.

|]
  where
    nicht :: Bool -> String
    nicht f = if f then "nicht" else ""
    -- to avoid inline type annotations due to String vs Text
    auch :: String
    auch = " auch"
    
    hint1 = [i|Ben kommt #{nicht b} mit, wenn Astrid #{nicht a} mitkommt.|] :: String
    hint2 = [i|Wenn Ben #{nicht b} kommt, kommt #{if b == c then auch else ""} Claudia #{nicht c}.|] :: String
    hint3 = [i|Wenn Claudia #{nicht c} kommt, kommt #{if c == d then auch else ""} David #{nicht d}.|] :: String
    hint4 = 
      (if b == d
         then [i|Falls Ben und David #{nicht b} kommen,|]
         else
           if b
             then "Falls Ben nicht, aber David kommt,"
             else "Falls Ben, aber nicht David kommt,")
      ++ [i| kommt Claudia #{nicht (not c)}.|] :: String

    hint5 = 
      [i|Wenn David #{nicht d} kommt, |] ++
      if a == b
        then [i|kommen #{if d == a then auch else ""} Astrid oder Ben #{nicht a}.|]
        else
          if a
            then [i|kommt #{if d then auch else ""} Astrid nicht oder Ben kommt.|]
            else [i|kommt #{if d then "" else auch} Astrid oder Ben kommt nicht.|]


description :: String
description = "We'll be right back..." 
{-
description = [i|
Eva would like to see a concert of her favourite band. 
She asks her friends Astrid (A), Ben (B), Claudia (C) and David (D) to accompany her.
But their answers turn out to be a little strange.

- If Ben and David go, then Claudia won't go.
- Ben will go if Astrid goes.
- If Ben goes, then Claudia will go too.
- If Claudia goes, then David will go too.
- If David goes, then Astrid or Ben will go too.
|]
-}

fieldNames :: [[FieldInfo]]
fieldNames = [[Single "Formel"], [ChoicesButtons Vertical "Wer kommt?" ["Anna","Ben","Claudia","David"]]]


widget :: Html -> MForm Handler (FormResult (Text,[Namen]), Widget) 
widget = formify fieldNames

=============================================

{-# language DeriveGeneric #-}
{-# language OverloadedStrings #-}
module ParseAndCheck where


import Data.String.Interpolate(i)
import Data.Text (Text)
import Text.Parsec (ParseError, parse)
import GHC.Generics

import ParseUtil

import qualified Data.Text as T

data Namen = Anna | Ben | Claudia | David deriving (Eq,Enum,Bounded,Show)

instance Parse [Namen] where
  parseInput = parseInstanceMultiChoice


data Table = Table [[Maybe Text]] deriving (Show,Eq)

type Solution = (Table,Text,[Namen])


parseSubmission :: String -> Either ParseError (Text,[Namen])
parseSubmission = parse parseInput ""

=============================================

\solution -> [i|

checkSyntax :: Either ParseError (Text,[Namen]) -> Maybe String
checkSyntax (Left err) = Just $ show err
checkSyntax (Right (t,n))
    | null n = Just "Es wurden keine Namen agekreuzt."
    | T.any func t = Just "Die Formel enthält Zahlen."
    | T.any func2 "ABCD" = Just "Die Formel enthält nicht alle vorkommenden Literale."
    | otherwise = Nothing
  where
    func c = c `elem` ['1'..'9']
    func2 c = not (c `T.elem` t)    

checkSemantics :: Either ParseError (Text,[Namen]) -> Maybe String
checkSemantics (Left err) = Just $ show err
checkSemantics (Right (t,n))
    | n /= nSol = Just "Die List der Tielnehmer ist falsch."
    | t /= tSol = Just "Die aussagenlogische Formel ist falsch."
    | otherwise = Nothing
  where
    (_,tSol,nSol) = sol 

sol = #{solution}
|]


