module Global where


import Data.Text (Text)




newtype Binary = Binary { unBinary :: Bool} deriving (Eq,Show)

newtype Formula = Formula { unFormula :: Text} deriving (Eq,Show)


data Table = Table [(Maybe Formula, [Maybe Binary])] deriving (Eq,Show)

data Namen = Anna | Ben | Claudia | David deriving (Eq,Enum,Bounded,Show)


type Solution = (Text,[Namen])

type Submission = (Table,Text,[Namen])


validSymbols :: String
validSymbols = "ABCD∧∨⇒⇔¬() "

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
{-# Language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}
module TaskAndForm where


import Control.OutputCapable.Blocks
import Control.OutputCapable.Blocks.Generic.Type (
    GenericOutput
    )
import Data.List.Split         (chunksOf)
import Data.Text               (Text)
import Data.String.Interpolate (i)
import FlexTask.FormUtil       (($$>), getFormData, newFlexId, newFlexName)
import FlexTask.Generic.Form (
  Alignment(..),
  FieldInfo(..),
  Formify(..),
  formify,
  formifyInstanceMultiChoice
  )
import FlexTask.YesodConfig    (Handler, FlexForm, Rendered)
import Test.QuickCheck.Gen
import Text.Blaze.Internal     (MarkupM)
import Yesod

import qualified Data.Text as T

import Global




instance MonadFail Gen where
  fail = error


getParticipants :: Gen [Bool]
getParticipants = suchThat (vectorOf 4 chooseAny) $ not . all (==False)


getTask :: OutputCapable m => FilePath -> Gen (LangM m, String, IO ([Text],Html))
getTask _ = do
    values@[a,b,c,d] <- getParticipants
    let f = formula a b c d
        description = output a b c d
        zipped = zip values ([minBound .. maxBound] :: [Namen])
        coming = [ n | (b,n) <- zipped, b==True]
    pure (description, interpolate (f,coming), getFormData form)



formula :: Bool -> Bool -> Bool -> Bool -> Text
formula a b c d = [i|(#{part4}) ∧ (#{part1}) ∧ (#{part2}) ∧ (#{part3}) ∧ (#{part5})|]
  where
    neg f x = if f then "¬ " ++ x else x
    part1 = [i|#{neg a "A"} ⇒ #{neg b "B"}|] :: Text
    part2 = [i|#{neg b "B"} ⇒ #{neg c "C"}|] :: Text
    part3 = [i|#{neg c "C"} ⇒ #{neg d "D"}|] :: Text
    part4 = [i|(#{neg b "B"} ∧ #{neg d "D"}) ⇒ #{neg (not c) "C"}|] :: Text
    part5 = [i|#{neg d "D"} ⇒ (#{neg a "A"} ∨ #{neg b "B"})|] :: Text



output :: OutputCapable m => Bool -> Bool -> Bool -> Bool -> LangM m
output a b c d = do
    paragraph $ translate $ german
      ( "Eva möchte gerne auf ein Konzert ihrer Lieblingsband gehen. " ++
        "Sie fragt ihre Freunde Astrid (A), Ben (B), Claudia (C) und David (D), " ++
        "ob sie mitkommen wollen. Leider sind die Antworten etwas seltsam."
      )
    itemizeM
      [ translate $ german $
          (if b == d
             then [i|Falls Ben und David #{nicht b} kommen,|]
             else
               if b
                 then "Falls Ben nicht, aber David kommt,"
                 else "Falls Ben, aber nicht David kommt,")
          ++ [i| kommt Claudia #{nicht (not c)}.|]
      , translate $ german
          [i|Ben kommt #{nicht b} mit, wenn Astrid #{nicht a} mitkommt.|]
      , translate $ german
          [i|Wenn Ben #{nicht b} kommt, kommt #{if b == c then auch else ""} Claudia #{nicht c}.|]
      , translate $ german
          [i|Wenn Claudia #{nicht c} kommt, kommt #{if c == d then auch else ""} David #{nicht d}.|]
      , translate $ german $
          [i|Wenn David #{nicht d} kommt, |] ++
          if a == b
            then [i|kommen #{if d == a then auch else ""} Astrid oder Ben #{nicht a}.|]
            else
              if a
                then [i|kommt #{if d then auch else ""} Astrid nicht oder Ben kommt.|]
                else [i|kommt #{if d then "" else auch} Astrid oder Ben kommt nicht.|]
      ]
    paragraph $ translate $ german
      "Übersetzen Sie die Aussagen in eine aussagenlogische Formel. Geben Sie diese Formel in das gleichnamige Textfeld ein."
    paragraph $ translate $ german
      "Wer geht mit Eva zum Konzert? Begründen Sie Ihr Ergebnis systematisch. Kreuzen Sie dafür alle Konzertgänger in der Namensliste an."
    paragraph $ translate $ german
      "Verwenden Sie für die Angabe der Formel die atomaren Formeln A,B,C,D und die folgenden Operatoren:"
    enumerateM code $ zip ["Negation","Und","Oder","Implikation","Biimplikation"] $ map code ["¬","∧","∨","⇒","⇔"]
    pure ()
  where
    nicht :: Bool -> String
    nicht f = if f then "nicht" else ""
    -- to avoid inline type annotations due to String vs Text
    auch :: String
    auch = " auch"



tableForm :: [Text] -> Int -> Int -> Rendered
tableForm staticHeaders rowAmount columnAmount extra = do
    let addCssClass fs = fs {fsAttrs = addClass "tableInput" (fsAttrs fs)}
        addFieldAttrs t = (fieldSettingsLabel t) {fsName = Just t}

        tableTextField :: Text -> MForm Handler (FormResult (Maybe Text),FieldView FlexForm)
        tableTextField t = mopt textField (addCssClass (addFieldAttrs t)) Nothing

        headerList = replicate (columnAmount - length staticHeaders) "headers"
        cellList = replicate (rowAmount*columnAmount) "cells"

    headersRes <- traverse tableTextField headerList
    columnsRes <- traverse tableTextField cellList
    let headers = map snd headersRes
        rows = chunksOf columnAmount $ map snd columnsRes
    pure ( ["headers","cells"]
         , [whamlet|
             <style>
               .tableInput {
                 width: 100%;
               }
               table, th, td {
                 border: 1px solid black;
                 border-collapse: collapse;

               }
               table {
                 width: 100%;
               }
             #{extra}
             <table>
               <tr>
                 $forall sh <- staticHeaders
                   <th>#{sh}
                 $forall header <- headers
                   <th>^{fvInput header}
               $forall row <- rows
                 <tr>
                   $forall input <- row
                     <td>^{fvInput input}|]
         )


instance Formify [Namen] where
  formifyImplementation = formifyInstanceMultiChoice



nonTableFields :: [[FieldInfo]]
nonTableFields = [[Single "Formel"], [ChoicesButtons Vertical "Wer kommt?" ["Anna","Ben","Claudia","David"]]]



form :: Rendered
form = tableForm ["A","B","C","D"] 16 7 $$> formify (Nothing :: Maybe Solution) nonTableFields

=============================================

{-# language ApplicativeDo #-}
{-# language DeriveGeneric #-}
{-# language OverloadedStrings #-}
module ParseAndCheck where


import Data.Char               (showLitChar)
import Data.String.Interpolate (i)
import Data.Text               (Text)
import Data.List               (transpose)
import Data.List.Split         (chunksOf)
import FlexTask.Generic.Parse (
  Parse(..),
  parseInstanceMultiChoice,
  escaped
  )
import Text.Parsec (
  (<|>),
  ParseError,
  choice,
  many1,
  parse,
  string,
  try
  )
import Text.Parsec.Char       (char, oneOf)
import Text.Parsec.String     (Parser)

import qualified Data.Text as T

import Global




instance Parse Binary where
  parseInput = escaped $ do
    val <- string "0" <|> string "1"
    pure $ Binary $ toEnum $ read val



instance Parse Formula where
  parseInput = escaped $ do
    symbols <- many1 $ choice $ map (try . char) validSymbols
    pure $ Formula $ T.pack $ symbols



instance Parse [Namen] where
  parseInput = parseInstanceMultiChoice



instance Parse Table where
  parseInput = do
    (headers,values) <- parseInput
    let allHeaders = map (Just . Formula) ["A","B","C","D"] ++ headers
    pure $ Table $ zip allHeaders $ transpose $ chunksOf 7 values



parseSubmission :: String -> Either ParseError Submission
parseSubmission = parse parseInput ""

=============================================

interpolate solution = [i|


import Control.Monad (when)
import Control.OutputCapable.Blocks
import Control.OutputCapable.Blocks.Generic.Type (
    GenericOutput
    )
import Data.Char     (digitToInt)
import Data.Functor  (($>))
import Data.Maybe    (catMaybes)
import Data.Ratio    (Ratio)
import Numeric       (showBin)



checkSyntax :: OutputCapable m => FilePath -> Either ParseError Submission -> LangM m
checkSyntax _ (Left err) = refuse $ code $ show err
checkSyntax _ (Right (Table xs,f,n))
    | any (`elem` (map (Just . Formula) ["A","B","C","D"])) nonStaticHeaders =
        indent $ refuse $ translate $ german
          "Mindestens eine der atomaren Formeln wurde mehrfach eingetragen."
    | null n =
        indent $ refuse $ translate $ german
          "Es wurden keine Namen angekreuzt. Es ist nicht möglich, dass keiner zum Konzert geht!"
    | T.any isNumber f = refuse $ translate $ german "Die Formel enthält Zahlen."
    | otherwise = pure ()
  where
    isNumber c = c `elem` ['1'..'9']
    (headers,columns) = unzip xs
    nonStaticHeaders = drop 4 headers


checkSemantics :: OutputCapable m => FilePath -> Either ParseError Submission -> Rated m
checkSemantics _ (Left err) = refuse (code $ show err) $> 0
checkSemantics _ (Right (Table xs,f,n)) = do
    when (take 4 columns /= startingTable) $
        indent $ refuse $ translate $ german
          "Die Spalten der atomaren Formeln ergeben keine sinnvolle Wahrheitstabelle."
    when (T.any notInAnswer "ABCD") $
        indent $ refuse $ translate $
           german "Die Formel enthält nicht alle vorkommenden Literale."
    when (f /= fSol) $
        indent $ refuse $ translate $ german "Die aussagenlogische Formel ist falsch."
    when (n /= nSol) $
        indent $ refuse $ translate $ german "Die Liste der Teilnehmer ist falsch."
    pure 1
  where
    notInAnswer c = not (c `T.elem` f)
    (headers,columns) = unzip xs
    nonStaticHeaders = drop 4 headers
    (fSol,nSol) = sol


startingTable :: [[Maybe Binary]]
startingTable = map (Just . Binary . toEnum . digitToInt) . T.unpack <$>
  T.transpose (T.justifyRight 4 '0' . T.pack . (`showBin` "") <$> [0..15])


sol = #{solution}
|]

