module Global where

import Data.Text
import GHC.Generics

newtype Binary = Binary { getBool :: Bool} deriving (Eq,Show)
newtype Formula = Formula {getFormula :: Text} deriving (Eq,Show)


data Table = Table [(Maybe Formula, [Maybe Binary])] deriving (Show,Eq,Generic)
data Namen = Anna | Ben | Claudia | David deriving (Eq,Enum,Bounded,Show)

type Solution = (Text,[Namen])

type Submission = (Table,Text,[Namen])


validSymbols :: String
validSymbols = "ABCD∧∨⇒⇔¬() "

=============================================
{-# language DeriveGeneric #-}
{-# Language FlexibleContexts #-}
{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}
module TaskAndForm where


import Data.List.Split (chunksOf)
import Data.Text (Text)
import Data.String.Interpolate(i)
import Test.QuickCheck.Gen
import Yesod

import FormUtil
import Global

import qualified Data.Text as T


instance MonadFail Gen where
  fail = error

instance Formify [Namen] where
  formifyImplementation = formifyInstanceMultiChoice



getParticipants :: Gen [Bool]
getParticipants = suchThat (vectorOf 4 chooseAny) $ not . all (==False)

getTask = do
    values@[a,b,c,d] <- getParticipants
    let f = formula a b c d
        description = output a b c d
        zipped = zip values ([minBound .. maxBound] :: [Namen])
        coming = [ n | (b,n) <- zipped, b==True]
    pure (description, show (f,coming), getHtml flattened widget, flattened)
  where
    flattened = [headerList 3, cellList 16 7] ++ flatten nonTableFields



formula :: Bool -> Bool -> Bool -> Bool -> Text
formula a b c d = [i|(#{part4}) ∧ (#{part1}) ∧ (#{part2}) ∧ (#{part3}) ∧ (#{part5})|]
  where
    neg f x = if f then "¬ " ++ x else x
    part1 = [i|#{neg a "A"} ⇒ #{neg b "B"}|] :: Text
    part2 = [i|#{neg b "B"} ⇒ #{neg c "C"}|] :: Text
    part3 = [i|#{neg c "C"} ⇒ #{neg d "D"}|] :: Text
    part4 = [i|(#{neg b "B"} ∧ #{neg d "D"}) ⇒ #{neg (not c) "C"}|] :: Text
    part5 = [i|#{neg d "D"} ⇒ (#{neg a "A"} ∨ #{neg b "B"})|] :: Text

output a b c d = (germanText a b c d,"")


germanText :: Bool -> Bool -> Bool -> Bool -> String
germanText a b c d = [i|
Eva möchte gerne auf ein Konzert ihrer Lieblingsband gehen.
Sie fragt ihre Freunde Astrid (A), Ben (B), Claudia (C) und David (D), ob sie mitkommen wollen.
Leider sind die Antworten etwas seltsam.

- #{hint4}
- #{hint1}
- #{hint2}
- #{hint3}
- #{hint5}

Übersetzen Sie die Aussagen in eine aussagenlogische Formel. Geben Sie diese Formel in das gleichnamige Textfeld ein.

Wer geht mit Eva zum Konzert? Begründen Sie Ihr Ergebnis systematisch. Kreuzen Sie dafür alle Konzertgänger in der Namensliste an.

Verwenden Sie für die Angabe der Formel die atomaren Formeln A,B,C,D und die folgenden Operatoren:

Negation:      ¬
Und:           ∧
Oder:          ∨
Implikation:   ⇒
Biimplikation: ⇔
|]
  where
    nicht :: Bool -> String
    nicht f = if f then "nicht" else ""
    -- to avoid inline type annotations due to String vs Text
    auch :: String
    auch = " auch"

    hint1 = [i|Ben kommt #{nicht b} mit, wenn Astrid #{nicht a} mitkommt.|] :: String
    hint2 = [i|Wenn Ben #{nicht b} kommt, kommt #{if b == c then auch else ""} Claudia #{nicht c}.|] :: String
    hint3 = [i|Wenn Claudia #{nicht c} kommt, kommt #{if c == d then auch else ""} David #{nicht d}.|] :: String
    hint4 =
      (if b == d
         then [i|Falls Ben und David #{nicht b} kommen,|]
         else
           if b
             then "Falls Ben nicht, aber David kommt,"
             else "Falls Ben, aber nicht David kommt,")
      ++ [i| kommt Claudia #{nicht (not c)}.|] :: String

    hint5 =
      [i|Wenn David #{nicht d} kommt, |] ++
      if a == b
        then [i|kommen #{if d == a then auch else ""} Astrid oder Ben #{nicht a}.|]
        else
          if a
            then [i|kommt #{if d then auch else ""} Astrid nicht oder Ben kommt.|]
            else [i|kommt #{if d then "" else auch} Astrid oder Ben kommt nicht.|]


tableForm :: [Text] -> Int -> Int -> Html -> MForm Handler (FormResult Table, Widget)
tableForm staticHeaders rowAmount columnAmount extra = do
    let addCssClass fs = fs {fsAttrs = addClass "tableInput" (fsAttrs fs)}

        tableTextField :: Text -> MForm Handler (FormResult (Maybe Text),FieldView FlexForm)
        tableTextField t = mopt textField (addCssClass (addName t)) Nothing

    headersRes <- sequence $ map tableTextField $ headerList (columnAmount - length staticHeaders)
    columnsRes <- sequence $ map tableTextField $ cellList rowAmount columnAmount
    let headers = map snd headersRes
        rows = chunksOf columnAmount $ map snd columnsRes
        widget =
         [whamlet|
             <style>
               .tableInput {
                 width: 100%;
               }
               table, th, td {
                 border: 1px solid black;
                 border-collapse: collapse;

               }
               table {
                 width: 100%;
               }
             #{extra}
             <table>
               <tr>
                 $forall sh <- staticHeaders
                   <th>#{sh}
                 $forall header <- headers
                   <th>^{fvInput header}
               $forall row <- rows
                 <tr>
                   $forall input <- row
                     <td>^{fvInput input}
         |]

    return (undefined, widget)


headerList :: Int -> [Text]
headerList amount = map (T.pack . ('h':) . show) [1..amount]

cellList :: Int -> Int -> [Text]
cellList rows columns = map (T.pack . show) [1..rows*columns]


nonTableFields :: [[FieldInfo]]
nonTableFields = [[Single "Formel"], [ChoicesButtons Vertical "Wer kommt?" ["Anna","Ben","Claudia","David"]]]



-- ugly! Maybe add a function to handle this
widget :: Html -> MForm Handler (FormResult Submission, Widget)
widget = do
  resLeft  <- tableForm ["A","B","C","D"] 16 7
  resRight <- (formify nonTableFields :: Rendered Solution)
  pure $ do
    (_,w1) <- resLeft
    (_,w2) <- resRight
    pure (undefined,w1 >> w2)


=============================================

{-# language DeriveGeneric #-}
{-# language OverloadedStrings #-}
module ParseAndCheck where


import Data.Char (showLitChar)
import Data.String.Interpolate(i)
import Data.Text (Text)
import Data.List (transpose)
import Data.List.Split (chunksOf)
import Text.Parsec ((<|>), ParseError, choice, many1, parse, string, try)
import Text.Parsec.Char (oneOf)
import Text.Parsec.String (Parser)
import GHC.Generics

import Global
import ParseUtil

import qualified Data.Text as T


instance Parse [Namen] where
  parseInput = parseInstanceMultiChoice

instance Parse Binary where
  parseInput = escaped $ do
    val <- string "0" <|> string "1"
    pure $ Binary $ toEnum $ read val

instance Parse Formula where
  parseInput = escaped $ do
    symbols <- many1 $ choice $ map (try. parseUnicode) validSymbols
    pure $ Formula $ T.pack $ read ('\"' : concat symbols ++ "\"")

instance Parse Table where
  parseInput = do
    (headers,values) <- parseInput
    let allHeaders = map (Just . Formula) ["A","B","C","D"] ++ headers
    pure $ Table $ zip allHeaders $ transpose $ chunksOf 7 values



parseSubmission :: String -> Either ParseError Submission
parseSubmission = parse parseInput ""

=============================================

\solution -> [i|


import Numeric
import Data.Maybe (catMaybes)


checkSyntax :: Either ParseError Submission -> Maybe String
checkSyntax (Left err) = Just $ show err
checkSyntax (Right (Table xs,f,n))
    | any (`elem` (map (Just . Formula) ["A","B","C","D"])) nonStaticHeaders = Just "Mindestens eine der atomaren Formeln wurde mehrfach eingetragen."
    | null n = Just "Es wurden keine Namen angekreuzt. Es ist nicht möglich, dass keiner zum Konzert geht!"
    | T.any isNumber f = Just "Die Formel enthält Zahlen."
    | otherwise = Nothing
  where
    isNumber c = c `elem` ['1'..'9']
    (headers,columns) = unzip xs
    nonStaticHeaders = drop 4 headers


checkSemantics :: Either ParseError Submission -> Maybe String
checkSemantics (Left err) = Just $ show err
checkSemantics (Right (Table xs,f,n))
    | take 4 columns /= startingTable = Just "Die Spalten der atomaren Formeln ergeben keine sinnvolle Wahrheitstabelle."
    | T.any notInAnswer "ABCD" = Just "Die Formel enthält nicht alle vorkommenden Literale."
    | f /= fSol = Just "Die aussagenlogische Formel ist falsch."
    | n /= nSol = Just "Die Liste der Teilnehmer ist falsch."
    | otherwise = Nothing
  where
    notInAnswer c = not (c `T.elem` f)
    (headers,columns) = unzip xs
    nonStaticHeaders = drop 4 headers
    (fSol,nSol) = sol


startingTable :: [[Maybe Binary]]
startingTable = map (Just . Binary . toEnum) . read . T.unpack <$> T.transpose (T.justifyRight 4 '0' . T.pack . (`showBin` "") <$> [0..15])


sol = #{solution}
|]


