module Global where

import Data.Map                         (Map)
import Tasks.ComposeFormula.Config (
  ComposeFormulaConfig(..),
  ComposeFormulaInst(..),
  TreeDisplayMode (TreeDisplay),
  )
import Tasks.SynTree.Config             (SynTreeConfig(..))
import Trees.Types                      (BinOp(..), SynTree(..), TreeFormulaAnswer)
import qualified Data.Map               as Map (fromList)


type Submission = [TreeFormulaAnswer]
type TaskData = ComposeFormulaInst


-- 2024: Weight 0.33
task03 :: ComposeFormulaConfig
task03 = ComposeFormulaConfig
  { syntaxTreeConfig = SynTreeConfig
    { minNodes = 10
    , maxNodes = 14
    , minDepth = 4
    , maxDepth = 6
    , availableAtoms = "ABCDE"
    , minAmountOfUniqueAtoms = 5
    , binOpFrequencies = listToFM
      [ (And, 1)
      , (Or, 1)
      , (Impl, 1)
      , (BackImpl, 1)
      , (Equi, 1)
      ]
    , negOpFrequency = 1
    , maxConsecutiveNegations = 2
    , minUniqueBinOperators = 2
    }
  , treeDisplayModes = (TreeDisplay, TreeDisplay)
  , extraHintsOnAssociativity = False
  , extraText = Nothing
  , printSolution = True
  , offerUnicodeInput = True
  }

-- For documentation and type checking. Not used in task.
defaultTaskData :: TaskData
defaultTaskData = ComposeFormulaInst
  { operator = And
  , leftTree = Leaf 'A'
  , rightTree = Leaf 'B'
  , leftTreeImage = Just "example.svg"
  , rightTreeImage = Nothing
  , addExtraHintsOnAssociativity = True
  , addText = Nothing
  , showSolution = False
  , unicodeAllowed = True
  }

listToFM :: Ord k => [(k, a)] -> Map k a
listToFM = Map.fromList

=============================================

{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}

module TaskData where

import Data.String.Interpolate          (i)
import FlexTask.FormUtil                (getFormData)
import FlexTask.Generic.Form
import FlexTask.YesodConfig             (Rendered)
import Tasks.ComposeFormula.Quiz        (generateComposeFormulaInst)
import Test.QuickCheck.Gen              (Gen)

import Global


getTask :: Gen (TaskData, String, IO ([String],String))
getTask = do
    inst <- generateComposeFormulaInst task03
    pure (inst, checkers, getFormData form)

fields :: [[FieldInfo]]
fields = [[single "Erste Formel:", single "Zweite Formel:"]]

form :: Rendered
form = formify (Nothing :: Maybe (String,String)) fields

checkers :: String
checkers = [i|

{-\# language ApplicativeDo \#-}

module Check where

import Control.Monad.IO.Class           (MonadIO)
import Control.OutputCapable.Blocks
import Data.Functor                     (($>))
import LogicTasks.Syntax.ComposeFormula (partialGrade', completeGrade')

import Global


checkSyntax
  :: (MonadIO m, OutputCapable m)
  => TaskData
  -> FilePath
  -> Submission
  -> LangM m
checkSyntax inst _ = partialGrade' inst

checkSemantics
  :: (MonadIO m, OutputCapable m)
  => TaskData
  -> FilePath
  -> Submission
  -> Rated m
checkSemantics inst path try = completeGrade' path inst try $> 1.0

|]

=============================================

{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE RecordWildCards #-}

module Description (description) where

import Control.Monad.IO.Class           (MonadIO)
import Control.OutputCapable.Blocks
import Tasks.ComposeFormula.Config      (ComposeFormulaInst(..))

import qualified LogicTasks.Syntax.ComposeFormula as LT

import Global

description :: (OutputCapable m, MonadIO m) => FilePath -> TaskData -> LangM m
description path inst@ComposeFormulaInst{..} = do
  LT.description False (path <> "/") inst
  paragraph $ do
    translate $ do
      german "Ein Lösungsversuch könnte beispielsweise aus den folgenden beiden Eingaben bestehen: "
      english "For instance, a solution attempt could consist of the following two inputs: "
    translatedCode $ flip localise $ translations exampleCode
    pure()
  pure()
  where
    (fixedEng, fixedGer) = ("C and (A or not B)","C und (A oder nicht B)")
    exampleCode
      | unicodeAllowed = do
        english $ unlines ["(A ∨ ¬B) and C", fixedEng]
        german $ unlines ["(A ∨ ¬B) und C", fixedGer]
      | otherwise      = do
        english $ unlines ["(A or not B) and C", fixedEng]
        german $ unlines ["(A oder nicht B) und C", fixedGer]

=============================================

module Parse (parseSubmission) where

import Control.OutputCapable.Blocks (
  LangM',
  OutputCapable,
  ReportT,
  )
import Control.OutputCapable.Blocks.Generic (
  ($>>=),
  )
import FlexTask.Generic.Parse  (parseInput, parseWithFallback, useParser)
import Formula.Parsing.Delayed (
  complainAboutMissingParenthesesIfNotFailingOn,
  )
import LogicTasks.Parsing (formulaSymbolParser, parser)

import Global


parseSubmission ::
  (Monad m, OutputCapable (ReportT o m))
  => String
  -> LangM' (ReportT o m) Submission
parseSubmission input = useParser parseInput input $>>= \(input1,input2) ->
  parseIt input1 $>>= \formula1 ->
    parseIt input2 $>>= \formula2 ->
      pure [formula1,formula2]
  where
    parseIt = parseWithFallback
      parser
      complainAboutMissingParenthesesIfNotFailingOn
      formulaSymbolParser
