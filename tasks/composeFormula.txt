module Global where


type Solution = (String,String)

=============================================

{-# language OverloadedStrings #-}
{-# Language QuasiQuotes #-}

module TaskAndForm where


import Control.Monad.IO.Class           (MonadIO)
import Control.OutputCapable.Blocks
import Control.OutputCapable.Blocks.Generic.Type (
    GenericOutput
    )
import Data.String.Interpolate          (i)
import Data.Text                        (Text)
import FlexTask.FormUtil                (getFormData)
import FlexTask.Generic.Form
import FlexTask.YesodConfig             (Handler, Rendered)
import LogicTasks.Syntax.ComposeFormula (description)
import Tasks.ComposeFormula.Config      (defaultComposeFormulaConfig)
import Tasks.ComposeFormula.Quiz        (generateComposeFormulaInst)
import Test.QuickCheck.Gen              (Gen)

import Global



getTask
  :: (MonadIO m, OutputCapable m)
  => FilePath
  -> Gen (LangM m, String, IO ([String],String))
getTask path = do
    inst <- generateComposeFormulaInst defaultComposeFormulaConfig
    let text = description (path <> "/") inst
    pure (text, interpolate inst, getFormData form)



fields :: [[FieldInfo]]
fields = [[single "First Formula", single "Second Formula"]]



form :: Rendered
form = formify (Nothing :: Maybe Solution) fields

=============================================

{-# language ApplicativeDo #-}

module ParseAndCheck where


import FlexTask.Generic.Parse  (Parse(parseInput))
import Text.Parsec             (ParseError, parse)

import Global



parseSubmission :: String -> Either ParseError Solution
parseSubmission = parse parseInput ""

=============================================

interpolate inst = [i|


import Control.Monad.IO.Class           (MonadIO (liftIO))
import Control.OutputCapable.Blocks
import Control.OutputCapable.Blocks.Generic.Type (
    GenericOutput
    )
import Data.Ratio
import Formula.Parsing.Delayed          (delayed)
import LogicTasks.Syntax.ComposeFormula (partialGrade, completeGrade)
import Tasks.ComposeFormula.Config      (ComposeFormulaInst(..))
import Trees.Types                      (BinOp(..), SynTree(..), TreeFormulaAnswer)


toListString :: (String,String) -> String
toListString (x,y) = '[' : x ++ ',' : y ++ "]"


checkSyntax
  :: (MonadIO m, OutputCapable m)
  => FilePath
  -> Either ParseError Solution
  -> LangM m
checkSyntax _ (Left err) = refuse $ code $ show err
checkSyntax _ (Right try) = partialGrade inst $ delayed $ toListString try



checkSemantics
  :: (MonadIO m, OutputCapable m)
  => FilePath
  -> Either ParseError Solution
  -> Rated m
checkSemantics _ (Left err) = refuse (code $ show err) *> pure 0.0
checkSemantics path (Right try) = completeGrade path inst (delayed $ toListString try) *> pure 1.0


inst = #{inst}
|]
